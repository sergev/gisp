// Metacircular evaluator from SICP (Sections 4.1.1â€“4.1.4) rewritten using the Go-like Gisp syntax.

// List helpers
func mapList(proc, lst) {
	if nullp(lst) {
		return [];
	}
	return cons(proc(car(lst)), mapList(proc, cdr(lst)));
}

func cadr(x) {
	return car(cdr(x));
}

func caddr(x) {
	return car(cdr(cdr(x)));
}

func cadddr(x) {
	return car(cdr(cdr(cdr(x))));
}

func cdadr(x) {
	return cdr(car(cdr(x)));
}

func caadr(x) {
	return car(car(cdr(x)));
}

func cddr(x) {
	return cdr(cdr(x));
}

func cdddr(x) {
	return cdr(cdr(cdr(x)));
}

// Preserve access to host apply
var applyInUnderlyingScheme = `apply;

// SECTION 4.1.1

func eval(exp, env) {
	return switch {
	case isSelfEvaluating(exp): exp;
	case isVariable(exp): lookupVariableValue(exp, env);
	case isQuoted(exp): textOfQuotation(exp);
	case isAssignment(exp): evalAssignment(exp, env);
	case isDefinition(exp): evalDefinition(exp, env);
	case isIf(exp): evalIf(exp, env);
	case isLambda(exp):
		makeProcedure(lambdaParameters(exp), lambdaBody(exp), env);
	case isBegin(exp):
		evalSequence(beginActions(exp), env);
	case isCond(exp):
		eval(condToIf(exp), env);
	case isApplication(exp):
		apply(eval(operator(exp), env), listOfValues(operands(exp), env));
	default:
		error("Unknown expression type -- EVAL", exp);
	};
}

func apply(procedure, arguments) {
	return switch {
	case isPrimitiveProcedure(procedure):
		applyPrimitiveProcedure(procedure, arguments);
	case isCompoundProcedure(procedure):
		evalSequence(
			procedureBody(procedure),
			extendEnvironment(
				procedureParameters(procedure),
				arguments,
				procedureEnvironment(procedure)
			)
		);
	default:
		error("Unknown procedure type -- APPLY", procedure);
	};
}

func listOfValues(exps, env) {
	if noOperands(exps) {
		return [];
	}
	return cons(eval(firstOperand(exps), env), listOfValues(restOperands(exps), env));
}

func evalIf(exp, env) {
	if isTrue(eval(ifPredicate(exp), env)) {
		return eval(ifConsequent(exp), env);
	}
	return eval(ifAlternative(exp), env);
}

func evalSequence(exps, env) {
	if isLastExp(exps) {
		return eval(firstExp(exps), env);
	}
	eval(firstExp(exps), env);
	return evalSequence(restExps(exps), env);
}

func evalAssignment(exp, env) {
	setVariableValue(assignmentVariable(exp), eval(assignmentValue(exp), env), env);
	return `(quote ok);
}

func evalDefinition(exp, env) {
	defineVariable(definitionVariable(exp), eval(definitionValue(exp), env), env);
	return `(quote ok);
}

// SECTION 4.1.2

func isSelfEvaluating(exp) {
	return switch {
	case numberp(exp): true;
	case stringp(exp): true;
	default: false;
	};
}

func isQuoted(exp) {
	return isTaggedList(exp, `'quote);
}

func textOfQuotation(exp) {
	return cadr(exp);
}

func isTaggedList(exp, tag) {
	if pairp(exp) {
		return eq(car(exp), tag);
	}
	return false;
}

func isVariable(exp) {
	return symbolp(exp);
}

func isAssignment(exp) {
	return isTaggedList(exp, `'set!);
}

func assignmentVariable(exp) {
	return cadr(exp);
}

func assignmentValue(exp) {
	return caddr(exp);
}

func isDefinition(exp) {
	return isTaggedList(exp, `'define);
}

func definitionVariable(exp) {
	if symbolp(cadr(exp)) {
		return cadr(exp);
	}
	return caadr(exp);
}

func definitionValue(exp) {
	if symbolp(cadr(exp)) {
		return caddr(exp);
	}
	return makeLambda(cdadr(exp), cddr(exp));
}

func isLambda(exp) {
	return isTaggedList(exp, `'lambda);
}

func lambdaParameters(exp) {
	return cadr(exp);
}

func lambdaBody(exp) {
	return cddr(exp);
}

func makeLambda(parameters, body) {
	return cons(`'lambda, cons(parameters, body));
}

func isIf(exp) {
	return isTaggedList(exp, `'if);
}

func ifPredicate(exp) {
	return cadr(exp);
}

func ifConsequent(exp) {
	return caddr(exp);
}

func ifAlternative(exp) {
	if not(nullp(cdddr(exp))) {
		return cadddr(exp);
	}
	return false;
}

func makeIf(predicate, consequent, alternative) {
	return [`'if, predicate, consequent, alternative];
}

func isBegin(exp) {
	return isTaggedList(exp, `'begin);
}

func beginActions(exp) {
	return cdr(exp);
}

func isLastExp(seq) {
	return nullp(cdr(seq));
}

func firstExp(seq) {
	return car(seq);
}

func restExps(seq) {
	return cdr(seq);
}

func sequenceToExp(seq) {
	return switch {
	case nullp(seq): seq;
	case isLastExp(seq): firstExp(seq);
	default: makeBegin(seq);
	};
}

func makeBegin(seq) {
	return cons(`'begin, seq);
}

func isApplication(exp) {
	return pairp(exp);
}

func operator(exp) {
	return car(exp);
}

func operands(exp) {
	return cdr(exp);
}

func noOperands(ops) {
	return nullp(ops);
}

func firstOperand(ops) {
	return car(ops);
}

func restOperands(ops) {
	return cdr(ops);
}

func isCond(exp) {
	return isTaggedList(exp, `'cond);
}

func condClauses(exp) {
	return cdr(exp);
}

func isCondElseClause(clause) {
	return eq(condPredicate(clause), `'else);
}

func condPredicate(clause) {
	return car(clause);
}

func condActions(clause) {
	return cdr(clause);
}

func condToIf(exp) {
	return expandClauses(condClauses(exp));
}

func expandClauses(clauses) {
	if nullp(clauses) {
		return false;
	}

	var first = car(clauses);
	var rest = cdr(clauses);

	if isCondElseClause(first) {
		if nullp(rest) {
			return sequenceToExp(condActions(first));
		}
		return error("ELSE clause isn't last -- COND->IF", clauses);
	}

	return makeIf(
		condPredicate(first),
		sequenceToExp(condActions(first)),
		expandClauses(rest)
	);
}

// SECTION 4.1.3

func isTrue(x) {
	return not(eq(x, false));
}

func isFalse(x) {
	return eq(x, false);
}

func makeProcedure(parameters, body, env) {
	return [`'procedure, parameters, body, env];
}

func isCompoundProcedure(p) {
	return isTaggedList(p, `'procedure);
}

func procedureParameters(p) {
	return cadr(p);
}

func procedureBody(p) {
	return caddr(p);
}

func procedureEnvironment(p) {
	return cadddr(p);
}

func enclosingEnvironment(env) {
	return cdr(env);
}

func firstFrame(env) {
	return car(env);
}

var theEmptyEnvironment = [];

func makeFrame(variables, values) {
	return cons(variables, values);
}

func frameVariables(frame) {
	return car(frame);
}

func frameValues(frame) {
	return cdr(frame);
}

func addBindingToFrame(variable, value, frame) {
	setCar(frame, cons(variable, car(frame)));
	setCdr(frame, cons(value, cdr(frame)));
}

func extendEnvironment(vars, vals, baseEnv) {
	if length(vars) == length(vals) {
		return cons(makeFrame(vars, vals), baseEnv);
	}
	if length(vars) < length(vals) {
		return error("Too many arguments supplied", vars, vals);
	}
	return error("Too few arguments supplied", vars, vals);
}

func lookupVariableValue(variable, env) {
	var currentEnv = env;
	while true {
		if eq(currentEnv, theEmptyEnvironment) {
			return error("Unbound variable", variable);
		}

		var frame = firstFrame(currentEnv);
		var vars = frameVariables(frame);
		var vals = frameValues(frame);

		while not(nullp(vars)) {
			if eq(variable, car(vars)) {
				return car(vals);
			}
			vars = cdr(vars);
			vals = cdr(vals);
		}

		currentEnv = enclosingEnvironment(currentEnv);
	}
}

func setVariableValue(variable, value, env) {
	var currentEnv = env;
	while true {
		if eq(currentEnv, theEmptyEnvironment) {
			return error("Unbound variable -- SET!", variable);
		}

		var frame = firstFrame(currentEnv);
		var vars = frameVariables(frame);
		var vals = frameValues(frame);

		while not(nullp(vars)) {
			if eq(variable, car(vars)) {
				setCar(vals, value);
				return;
			}
			vars = cdr(vars);
			vals = cdr(vals);
		}

		currentEnv = enclosingEnvironment(currentEnv);
	}
}

func defineVariable(variable, value, env) {
	var frame = firstFrame(env);
	var vars = frameVariables(frame);
	var vals = frameValues(frame);

	while not(nullp(vars)) {
		if eq(variable, car(vars)) {
			setCar(vals, value);
			return;
		}
		vars = cdr(vars);
		vals = cdr(vals);
	}

	addBindingToFrame(variable, value, frame);
}

// SECTION 4.1.4

func setupEnvironment() {
	var initialEnv = extendEnvironment(
		primitiveProcedureNames(),
		primitiveProcedureObjects(),
		theEmptyEnvironment
	);
	defineVariable(`'true, true, initialEnv);
	defineVariable(`'false, false, initialEnv);
	return initialEnv;
}

`(define setup-environment setupEnvironment);

func isPrimitiveProcedure(proc) {
	return isTaggedList(proc, `'primitive);
}

func primitiveImplementation(proc) {
	return cadr(proc);
}

var primitiveProcedures = [
	[`'car, car],
	[`'cdr, cdr],
	[`'cons, cons],
	[`'null?, nullp],
	[`'pair?, pairp],
	[`'eq?, eq],
	[`'+, `+],
	[`'-, `-],
	[`'*, `*],
	[`'/, `/],
	[`'=, `=],
	[`'<, `<],
	[`'<=, `<=],
	[`'>, `>],
	[`'>=, `>=],
	[`'not, not],
	[`'list, list],
	[`'number?, numberp],
	[`'symbol?, symbolp],
	[`'boolean?, booleanp],
	[`'map, mapList]
];

func primitiveProcedureNames() {
	return mapList(car, primitiveProcedures);
}

func primitiveProcedureObjects() {
	return mapList(func(proc) {
		return [`'primitive, cadr(proc)];
	}, primitiveProcedures);
}

func applyPrimitiveProcedure(proc, args) {
	return applyInUnderlyingScheme(primitiveImplementation(proc), args);
}

var inputPrompt = ";;; M-Eval input:";
var outputPrompt = ";;; M-Eval value:";

func driverLoop() {
	promptForInput(inputPrompt);
	var input = read();
	var output = eval(input, theGlobalEnvironment);
	announceOutput(outputPrompt);
	userPrint(output);
	driverLoop();
}

func promptForInput(text) {
	newline();
	newline();
	display(text);
	newline();
}

func announceOutput(text) {
	newline();
	display(text);
	newline();
}

func userPrint(object) {
	if isCompoundProcedure(object) {
		display([
			`'compound-procedure,
			procedureParameters(object),
			procedureBody(object),
			`'<procedure-env>
		]);
		return;
	}
	display(object);
}

// Optional boot sequence from original file. Uncomment to run interactively.
// var theGlobalEnvironment = setupEnvironment();
// driverLoop();

`(quote METACIRCULAR-EVALUATOR-LOADED);
