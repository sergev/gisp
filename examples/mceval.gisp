// Metacircular evaluator from SICP (Sections 4.1.1â€“4.1.4) rewritten using the Go-like Gisp syntax.

// List helpers
func cadr(x) {
    return first(rest(x))
}

func caddr(x) {
    return first(rest(rest(x)))
}

func cadddr(x) {
    return first(rest(rest(rest(x))))
}

func cdadr(x) {
    return rest(first(rest(x)))
}

func caadr(x) {
    return first(first(rest(x)))
}

func cddr(x) {
    return rest(rest(x))
}

func cdddr(x) {
    return rest(rest(rest(x)))
}

// Preserve access to host apply
var applyInUnderlyingScheme = `apply

// SECTION 4.1.1

func eval(exp, env) {
    return switch {
        case isSelfEvaluating(exp): exp
        case isVariable(exp): lookupVariableValue(exp, env)
        case isQuoted(exp): textOfQuotation(exp)
        case isAssignment(exp): evalAssignment(exp, env)
        case isDefinition(exp): evalDefinition(exp, env)
        case isIf(exp): evalIf(exp, env)
        case isLambda(exp):
        makeProcedure(lambdaParameters(exp), lambdaBody(exp), env)
        case isBegin(exp):
        evalSequence(beginActions(exp), env)
        case isCond(exp):
        eval(condToIf(exp), env)
        case isApplication(exp):
        apply(eval(operator(exp), env), listOfValues(operands(exp), env))
        default:
        error("Unknown expression type -- EVAL", exp)
    }
}

func apply(procedure, arguments) {
    return switch {
        case isPrimitiveProcedure(procedure):
        applyPrimitiveProcedure(procedure, arguments)
        case isCompoundProcedure(procedure):
        evalSequence(
        procedureBody(procedure),
        extendEnvironment(
        procedureParameters(procedure),
        arguments,
        procedureEnvironment(procedure)
        )
        )
        default:
        error("Unknown procedure type -- APPLY", procedure)
    }
}

func listOfValues(exps, env) {
    if noOperands(exps) {
        return []
    }
    return cons(eval(firstOperand(exps), env), listOfValues(restOperands(exps), env))
}

func evalIf(exp, env) {
    if isTrue(eval(ifPredicate(exp), env)) {
        return eval(ifConsequent(exp), env)
    }
    return eval(ifAlternative(exp), env)
}

func evalSequence(exps, env) {
    if isLastExp(exps) {
        return eval(firstExp(exps), env)
    }
    eval(firstExp(exps), env)
    return evalSequence(restExps(exps), env)
}

func evalAssignment(exp, env) {
    setVariableValue(assignmentVariable(exp), eval(assignmentValue(exp), env), env)
    return `(quote ok)
}

func evalDefinition(exp, env) {
    defineVariable(definitionVariable(exp), eval(definitionValue(exp), env), env)
    return `(quote ok)
}

// SECTION 4.1.2

func isSelfEvaluating(exp) {
    return switch {
        case numberp(exp): true
        case stringp(exp): true
        default: false
    }
}

func isQuoted(exp) {
    return isTaggedList(exp, `'quote)
}

func textOfQuotation(exp) {
    return cadr(exp)
}

func isTaggedList(exp, tag) {
    if pairp(exp) {
        return eq(first(exp), tag)
    }
    return false
}

func isVariable(exp) {
    return symbolp(exp)
}

func isAssignment(exp) {
    return isTaggedList(exp, `'set!)
}

func assignmentVariable(exp) {
    return cadr(exp)
}

func assignmentValue(exp) {
    return caddr(exp)
}

func isDefinition(exp) {
    return isTaggedList(exp, `'define)
}

func definitionVariable(exp) {
    if symbolp(cadr(exp)) {
        return cadr(exp)
    }
    return caadr(exp)
}

func definitionValue(exp) {
    if symbolp(cadr(exp)) {
        return caddr(exp)
    }
    return makeLambda(cdadr(exp), cddr(exp))
}

func isLambda(exp) {
    return isTaggedList(exp, `'lambda)
}

func lambdaParameters(exp) {
    return cadr(exp)
}

func lambdaBody(exp) {
    return cddr(exp)
}

func makeLambda(parameters, body) {
    return cons(`'lambda, cons(parameters, body))
}

func isIf(exp) {
    return isTaggedList(exp, `'if)
}

func ifPredicate(exp) {
    return cadr(exp)
}

func ifConsequent(exp) {
    return caddr(exp)
}

func ifAlternative(exp) {
    if not(nullp(cdddr(exp))) {
        return cadddr(exp)
    }
    return false
}

func makeIf(predicate, consequent, alternative) {
    return [`'if, predicate, consequent, alternative]
}

func isBegin(exp) {
    return isTaggedList(exp, `'begin)
}

func beginActions(exp) {
    return rest(exp)
}

func isLastExp(seq) {
    return nullp(rest(seq))
}

func firstExp(seq) {
    return first(seq)
}

func restExps(seq) {
    return rest(seq)
}

func sequenceToExp(seq) {
    return switch {
        case nullp(seq): seq
        case isLastExp(seq): firstExp(seq)
        default: makeBegin(seq)
    }
}

func makeBegin(seq) {
    return cons(`'begin, seq)
}

func isApplication(exp) {
    return pairp(exp)
}

func operator(exp) {
    return first(exp)
}

func operands(exp) {
    return rest(exp)
}

func noOperands(ops) {
    return nullp(ops)
}

func firstOperand(ops) {
    return first(ops)
}

func restOperands(ops) {
    return rest(ops)
}

func isCond(exp) {
    return isTaggedList(exp, `'cond)
}

func condClauses(exp) {
    return rest(exp)
}

func isCondElseClause(clause) {
    return eq(condPredicate(clause), `'else)
}

func condPredicate(clause) {
    return first(clause)
}

func condActions(clause) {
    return rest(clause)
}

func condToIf(exp) {
    return expandClauses(condClauses(exp))
}

func expandClauses(clauses) {
    if nullp(clauses) {
        return false
    }

    var first = first(clauses)
    var rest = rest(clauses)

    if isCondElseClause(first) {
        if nullp(rest) {
            return sequenceToExp(condActions(first))
        }
        return error("ELSE clause isn't last -- COND->IF", clauses)
    }

    return makeIf(
    condPredicate(first),
    sequenceToExp(condActions(first)),
    expandClauses(rest)
    )
}

// SECTION 4.1.3

func isTrue(x) {
    return not(eq(x, false))
}

func isFalse(x) {
    return eq(x, false)
}

func makeProcedure(parameters, body, env) {
    return [`'procedure, parameters, body, env]
}

func isCompoundProcedure(p) {
    return isTaggedList(p, `'procedure)
}

func procedureParameters(p) {
    return cadr(p)
}

func procedureBody(p) {
    return caddr(p)
}

func procedureEnvironment(p) {
    return cadddr(p)
}

func enclosingEnvironment(env) {
    return rest(env)
}

func firstFrame(env) {
    return first(env)
}

var theEmptyEnvironment = []

func makeFrame(variables, values) {
    return cons(variables, values)
}

func frameVariables(frame) {
    return first(frame)
}

func frameValues(frame) {
    return rest(frame)
}

func addBindingToFrame(variable, value, frame) {
    setFirst(frame, cons(variable, first(frame)))
    setRest(frame, cons(value, rest(frame)))
}

func extendEnvironment(vars, vals, baseEnv) {
    if length(vars) == length(vals) {
        return cons(makeFrame(vars, vals), baseEnv)
    }
    if length(vars) < length(vals) {
        return error("Too many arguments supplied", vars, vals)
    }
    return error("Too few arguments supplied", vars, vals)
}

func lookupVariableValue(variable, env) {
    var currentEnv = env
    while true {
        if eq(currentEnv, theEmptyEnvironment) {
            return error("Unbound variable", variable)
        }

        var frame = firstFrame(currentEnv)
        var vars = frameVariables(frame)
        var vals = frameValues(frame)

        while not(nullp(vars)) {
            if eq(variable, first(vars)) {
                return first(vals)
            }
            vars = rest(vars)
            vals = rest(vals)
        }

        currentEnv = enclosingEnvironment(currentEnv)
    }
}

func setVariableValue(variable, value, env) {
    var currentEnv = env
    while true {
        if eq(currentEnv, theEmptyEnvironment) {
            return error("Unbound variable -- SET!", variable)
        }

        var frame = firstFrame(currentEnv)
        var vars = frameVariables(frame)
        var vals = frameValues(frame)

        while not(nullp(vars)) {
            if eq(variable, first(vars)) {
                setFirst(vals, value)
                return
            }
            vars = rest(vars)
            vals = rest(vals)
        }

        currentEnv = enclosingEnvironment(currentEnv)
    }
}

func defineVariable(variable, value, env) {
    var frame = firstFrame(env)
    var vars = frameVariables(frame)
    var vals = frameValues(frame)

    while not(nullp(vars)) {
        if eq(variable, first(vars)) {
            setFirst(vals, value)
            return
        }
        vars = rest(vars)
        vals = rest(vals)
    }

    addBindingToFrame(variable, value, frame)
}

// SECTION 4.1.4

func setupEnvironment() {
    var initialEnv = extendEnvironment(
    primitiveProcedureNames(),
    primitiveProcedureObjects(),
    theEmptyEnvironment
    )
    defineVariable(`'true, true, initialEnv)
    defineVariable(`'false, false, initialEnv)
    return initialEnv
}

`(define setup-environment setupEnvironment)

func isPrimitiveProcedure(proc) {
    return isTaggedList(proc, `'primitive)
}

func primitiveImplementation(proc) {
    return cadr(proc)
}

var primitiveProcedures = [
[`'first, first],
[`'rest, rest],
[`'cons, cons],
[`'null?, nullp],
[`'pair?, pairp],
[`'eq?, eq],
[`'+, `+],
[`'-, `-],
[`'*, `*],
[`'/, `/],
[`'=, `=],
[`'<, `<],
[`'<=, `<=],
[`'>, `>],
[`'>=, `>=],
[`'not, not],
[`'list, list],
[`'number?, numberp],
[`'symbol?, symbolp],
[`'boolean?, booleanp],
[`'map, map]
]

func primitiveProcedureNames() {
    return map(first, primitiveProcedures)
}

func primitiveProcedureObjects() {
    return map(func(proc) {
        return [`'primitive, cadr(proc)]
    }, primitiveProcedures)
}

func applyPrimitiveProcedure(proc, args) {
    return applyInUnderlyingScheme(primitiveImplementation(proc), args)
}

var inputPrompt = ";;; M-Eval input:"
var outputPrompt = ";;; M-Eval value:"

func driverLoop() {
    promptForInput(inputPrompt)
    var input = read()
    var output = eval(input, theGlobalEnvironment)
    announceOutput(outputPrompt)
    userPrint(output)
    driverLoop()
}

func promptForInput(text) {
    newline()
    newline()
    display(text)
    newline()
}

func announceOutput(text) {
    newline()
    display(text)
    newline()
}

func userPrint(object) {
    if isCompoundProcedure(object) {
        display([
        `'compound-procedure,
        procedureParameters(object),
        procedureBody(object),
        `'<procedure-env>
        ])
        return
    }
    display(object)
}

// Optional boot sequence from original file. Uncomment to run interactively.
// var theGlobalEnvironment = setupEnvironment()
// driverLoop()

`(quote METACIRCULAR-EVALUATOR-LOADED)
